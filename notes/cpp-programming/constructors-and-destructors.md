[Home](../../) | [Projects](../../projects) | [Notes](../) > <a href="./">C++Â Programming</a> > Constructors & Destructors

# Constructors & Destructors



## Constructors

* Special member method
* Invoked during object creation
* Useful for initialization (to a stable state)
* Has same name as the class
* No return type is specified
* Can be overloaded

### Examples

* `Player` class

  ```cpp
  class Player
  {
  private:
      std::string name;
      int health;
      int xp;
  public:
      // Overloaded constructors
      Player();
      Player(std::string name);
      Player(std::string name, int health, int xp);
  };
  ```

* `Account` class

  ```cpp
  class Account
  {
  private:
      std::string name;
      double balance;
  public:
      // Constructors
      Account();
      Account(std::string name, double balance);
      Account(std::string name);
      Account(double balance);
  };
  ```

  

## Destructors

* Special member method
* Has same name as the class except that it is proceeded with a tilde (`~`)
* Invoked automatically when an object is destroyed (When an object goes out of its scope or a pointer pointing to an object gets deleted)
  * It is a great place to release memory, close files and free up any other resources.

* No return type and no parameters
* Only 1 destructor is allowed per class - CANNOT be overloaded!
  * Doesn't make sense to overload a destructor since it is called automatically by C++.

* Useful to release memory and other resources

### Example

* `Player` class

  ```cpp
  class Player
  {
  private:
      std::string name;
      int health;
      int xp;
  public:
      // Overloaded constructors
      Player();
      Player(std::string name);
      Player(std::string name, int health, int xp);
      // Destructor
      ~Player();
  };
  ```

  ```cpp
  {
      // The following 3 objects are all local and get created on stack memory
      Player jack;
      Player sunny {"Sunny", 100, 4};
      Player yena {"Yena"};
  } // 3 destructors called
  
  Player *kj = new Player("KJ", 1000, 0);
  delete enemy;	// Destructor called
  ```

* `Account` class

  ```cpp
  class Account
  {
  private:
      std::string name;
      double balance;
  public:
      // Constructors
      Account();
      Account(std::string name, double balance);
      Account(std::string name);
      Account(double balance);
      // Destructor
      ~Account();
  };
  ```

  

## Default Constructor

* A constructor that does not expect any arguments (Also, called the **no-args constructor**)
* If you do NOT provide any constructors at all for a class, C++ will generate a default constructor that does nothing.
  * Since the compiler generated default constructor does nothing, the class member attributes could contain garbage value because they haven't been initialized.

* Called when you instantiate a new object with no arguments
* It's a best practice to provide a user-defined constructor that ensures objects are instantiated in a known, stable (safe) state.
  * Once the user provides a user-defined constructor for a class, C++ will not generate the no-args default constructor automatically. If you still need it, then you must explicitly define it yourself.


### Examples

* `Player` class

  ```cpp
  Player jack;					// Creates an object on the stack
  Palyer *sunny = new Player;		// Creates an object on the heap
  ```

* `Account` class

  With default constructor

  ```cpp
  class Account
  {
  private:
      std::string name;
      double balance;
  public:
      // Default constructor
      Account()
      {
          name = "None";
          balance = 0.0;
      }
  	bool withdraw(double amount);
      bool deposit(double amount);
  };
  ```

  ```cpp
  Account jack_account;
  Account yena_account;
  
  Account *sunny_account = new Account;
  delete sunny_account;
  ```

  With a user-defined constructor (No default constructor)

  ```cpp
  class Account
  {
  private:
      std::string name;
      double balance;
  public:
      // No default constructor
      Account(std::string name_val, double bal)
      {
          name = name_val;
          balance bal;
      }
  	bool withdraw(double amount);
      bool deposit(double amount);
  };
  ```

  ```cpp
  Account jack_account;					// Error
  Account yena_account;					// Error
  
  Account *sunny_account = new Account;	// Error
  delete sunny_account;
  
  Account kj_account {"KJ", 15000.0};		// OK
  ```
  
  > Errors because the default constructor is no longer automatically generated by the compiler.



## Overloading Constructor

* Classes can have as many constructors as necessary
* Each must have a unique signature
* Default constructor is no longer compiler-generated once another constructor is declared
* It is important that we initialize our objects to some state that we know. We don't want garbage data in any of the attributes after they are created.

### Examples

* `Player` class

  ```cpp
  class player
  {
  private:
  	std::string name;
      int health;
      int xp;
  public:
      // Overloaded constructors
      Player();
      Player(std::string name_val);
      Player(std::string name_val, int health_val, int xp_val);
  };
  
  Player::Player()
  {
      name = "None";
      health = 0;
      xp = 0;
  }
  
  Player::Player(std::string name_val)
  {
      name = name_val;
      health = 0;
      xp = 0;
  }
  
  Player::Player(std::string name_val, int health_val, int xp_val)
  {
      name = name_val;
      health = health_val;
      xp = xp_val;
  }
  ```

  > L16: For the record, by the time that we get to this statement, the `name` string object has already been constructed and initialized to an empty string. So we're really just assigning a new string to it, in this case, to an existing object. This is, in reality, different from initialization. 
  >
  > $\to$ See "Constructor initialization lists" section.
  
  ```cpp
  Player empty;				// None, 0, 0
  Player hero("Hero");		// Hero, 0, 0
  Player villain("Villain");	// Villain, 0, 0
  Player frank {"Frank", 100, 4};					// Frank, 100, 4
  Player *enemy = new Player("Enemy", 1000, 0);	// Enemy, 1000, 0
  delete enemy;
  ```



## Constructor Initialization Lists

* So far, all data member values have been set in the constructor body. While this works, it technically isn't initialization because by the time the constructor body is executed these member attributes have already been created. So, we're really just assigning values to already created attributes.
* Constructor initialization lists help initialize the member data values to specified values BEFORE the constructor body executes. (True initialization!)
* Constructor initialization lists
  * Are more efficient
  * Immediately follows the parameter list
  * Initializes the data members as the object is created
  * Order of initialization is the order of their declarations in the class
    * The order specified in the initialization list does not matter!

### Examples

* `Player` class

  ```cpp
  class player
  {
  private:
  	std::string name;
      int health;
      int xp;
  public:
      // Overloaded constructors
      Player();
      Player(std::string name_val);
      Player(std::string name_val, int health_val, int xp_val);
  };
  
  Player::Player()
      : name{"None"}, health{0}, sp{0}					// Initialization list
  { }
  
  Player::Player::Player(std::string name_val)()
      : name{name_val}, health{0}, sp{0}					// Initialization list
  { }
  
  Player::Player(std::string name_val, int health_val, int xp_val)
      : name{name_val}, health{health_val}, xp{xp_val};	// Initialization list
  { }
  ```
  
  > Using constructor initialization lists, we can be sure that our data members have been initialized to our own values before any code in the constructor body is executed. $\to$ True initialization!



## Delegating Constructors

* Often the code for constructors is very similar. Many times only the initialization values of the data members is what chages.
* Duplicated code can lead to errors, so we want to minimize the amount of duplicated code in our programs.
* C++ allows delegating constructors
  * Code for one constructor can call another in the initialization list
  * Avoids duplicating code

### Examples

* `Player` class

  ```cpp
  class player
  {
  private:
  	std::string name;
      int health;
      int xp;
  public:
      // Overloaded constructors
      Player();
      Player(std::string name_val);
      Player(std::string name_val, int health_val, int xp_val);
  };
  
  Player::Player(std::string name_val, int health_val, int xp_val)
      : name{name_val}, health{health_val}, xp{xp_val};	// Initialization list
  { }
  
  Player::Player()
      : Player{"None", 0, 0}		// Delegating constructor
  { }
  
  Player::Player::Player(std::string name_val)()
      : Player{name_val, 0, 0}	// Delegating constructor
  { }
  ```
  
  > In this case, the no-args constructor is the delegating constructor, since it delegates object initialization to another constructor.



## Default Constructor Parameters

* Can often simplify our code and reduce the number of overloaded constructors by providing default constructor parameters.
* Same rules apply as we learned with non-member functions

### Examples

* `Player` class

  We can simply have one constructor that does everything that we did with the three constructors in the previous example.
  
  ```cpp
  class player
  {
  private:
  	std::string name;
      int health;
      int xp;
  public:
      // Constructor with default parameter values
      Player(std::string name_val = "None",
             int health_val = 0,
             int xp_val = 0);
  };
  
  Player::Player(std::string name_val, int health_val, int xp_val)
      : name{name_val}, health{health_val}, xp{xp_val}
  { }
  
  Player empty;					// None, 0, 0
  Player jack{"Jack"};			// Jack, 0, 0
  Player yena{"Yena", 100, 55};	// Yena, 100, 55
  Player hero{"Hero", 100};		// Hero, 100, 0
  ```
  
  > Notice that you don't supply the default parameters here. You can simply use an initializer list to initialize the class attributes, and the compiler will take care of providing the default values as needed.
  >
  > This is very handy and results in less code to write, which means less code to test, which means less code that could have errors.
  >
  > Since the single constructor is doing the job of several constructors, we have to be careful not to declare ambiguous constructors. For example, what would happen if you declared a no-args constructor? The compiler will generate an error since it doesn't know which one to call if no arguments were provided when creating an object.



## Copy Constructor

* When objects are copied C++ must create a new object from an existing object, and it uses "copy constructor" to do this. (Copy constructors are called whenever the compiler needs to make a copy of an object.)

* When is a copy of an object made?
  * Passing object by value as a parameter
  * Returning an object from a function by value
  * Constructing one object based on another of the same class
  
* C++ must have a way of accomplishing this so it provides a compiler-defined copy constructor if you don't. (If you don't provide your own way of copying objects by value then the compiler provides a default way of copying objects.)

* Copies the values of each data member to the new object
  * If you do not provide a user-defined copy constructor, C++ will generate a default copy constructor that will do member-wise copy.
  
* Perfectly fine in many cases, but beware if you have a pointer data member,the pointer will be copied not what it is pointing to.
  * Shallow copy vs. Deep copy
  
* Best practices
  * Provide a copy constructor when your class has raw pointer members
  * Provide the copy constructor with a **const reference** parameter
  * Use STL classes as member attributes as they already provide copy constructors
  * Avoid using raw pointer data members if possible or use smart pointers.
  
* Copy constructor signature

  ```cpp
  Type::Type(const Type &source);
  
  Player::Player(const Player &source);
  Account::Account(const Account &source);
  ```

  > Should pass the source object by constant reference!
  >
  > * Why pass by reference? $\to$ If we pass it in by value, then the passed object will get copied along the way, which is the whole point of the copy constructor. We would defeat the purpose and end up with never ending recursive calls.
  >
  > * Why constant? $\to$ Since we are copying the source without modifying it.

### Examples

* Pass object by value

  ```cpp
  Player hero{"Hero", 100, 20};
  
  void display_player(Player p)
  {
      // p is a COPY of hero in this example (copy constructor does the copy)
      // Use p
      // Destructor for p will be called
  }
  
  display_player(hero);
  ```

* Return object by value

  ```cpp
  Player enemy;
  
  Player create_super_enemy()
  {
      Player an_enemy{"Super Enemy", 100, 100};
      return an_enemy;	// A COPY of an_enemy is returned (copy constructor does the copy)
  }
  
  enemy = create_super_enemy();
  ```

  > Here, a copy of `an_enemy` object is made by the copy constructor.

* Construct one object based on another

  ```cpp
  Player hero{"Hero", 100, 100};
  Player another_hero{hero};			// A COPY of hero is made using the copy constructor
  ```

* Declaring and implementing a copy constructor

  ```cpp
  // Declaration
  Type::Type(const Type &source);
  
  // Implementation
  Type::Type(const Type &source)
  {
      // Code or initialization list to copy the object
  }
  ```

  ```cpp
  // Declaration
  Player::Player(const Player &source);
  Account::Account(const Account &source);
  
  // Implementation
  Player::Player(const Player &source)
      : name{source.name}, health{source.health}, xp{source.xp}
  { }
  
  Account::Account(const Account &source)
      : name{source.name}, balance{source.balance}
  { }
  ```

  

## Move Constructor

* One of C++11's most pervasive features was probably move semantics. And, to really understand move semantics, it's important to be able to tell whether an expression is an l-value or an r-value.

  Rule of thumb:

  * L-value

    When you can refer to an object by name or you can follow a pointer to get to an object, then that object is addressable and it's an l-value.

  * R-value

    Everything else

* In context of move semantics r-values refer to temporary objects that are created by the compiler, and objects returned from methods.

* Sometimes when we execute code the compiler creates unnamed temporary values:

  ```cpp
  int total{0};
  total = 100 + 200;
  ```

  > 1. `100 + 200` is evaluated and `300` stored in an unnamed `temp` value (This value is not addressable so it's an r-value.)
  >
  > 2. The `300` (r-value) is then stored in the variable `total` (l-value).
  >
  > 3. Then the `temp` value is discarded
  >

  The same happens with objects as well. However, with objects there can be a great amount of overhead if copy constructors are called over and over again making copies of these temporary objects. And, when we have raw pointers and we have to do deep copies then the overhead is even greater. 

  This is where move semantics and the move constructor comes into picture.

* Sometimes copy constructors are called many times automatically due to the copy semantics of C++.
* Copy constructors doing deep copying can have a significant performance bottleneck.

  * Deep copy must be implemented if a class contains a raw poiner.
  * This is computationally expensive since we have to allocate space for the copy and then copy the data over.

* C++11 introduced move semantics and the move constructor (Extremely efficient!)
* Move constructor moves an object rather than copy it.
* Move constructors are optional but recommended when you have a raw pointer.

  * If you don't provide them, then the copy constructors will be called.

* Copy elision - C++ may optimize copying away completely (RVO - Return Value Optimization)

  * You may not even see the copy constructors being called. If you experience this, it's probably due to something called copy elision.
  * Copy elision is a compiler optimization technique that eliminates unnecessary copying. Compilers are really smart with their optimizations now. And one of the common techniques is called "Return Value Optimization". That's when the compiler generates code that doesn't create a copy every return value from a function making the code much more efficient.


### What Does Move Constructor Do?

* Instead of making a deep copy of the resource
  * It simply **moves** the resource on the heap
  * Simply copies the address of the resource from source to the current object
  * And, nulls out the pointer in the source pointer.
* Very efficient since not doing a copy at all.

### R-value References (References to R-values)

* In the context of move semantics, think of r-value references as references to temporary objects.
* Used in moving semantics and perfect forwarding
* Move semantics is all about r-value references
* Used by move constructor and move assignment operator to efficiently move an object rather than copy it.
* R-value reference operator (`&&`)
  * This is unlike the l-value reference operator (`&`)


### Examples

* R-value references

  ```cpp
  // Syntax
  Type::Type(Type &&source);
  
  Player::Player(Player &&source);
  Move::Move(Move &&source);
  ```

  > Difference from copy constructors?
  >
  > * There's no `const ` qualifier for the parameter source because we need to modify it in order to null out its pointer.
  > * Parameter is an r-value reference  

  ```cpp
  int x{100};
  
  int &l_ref = x;		// L-value reference (since 'x' is an l-value, addressable, got a name)
  l_ref = 10;			// Change x to 10
  
  int &&r_ref = 200;	// R-value reference
  r_ref = 300;		// Change r_ref to 300 (just changed the temporary variable value!)
  
  int &&x_ref = x;	// Compiler error (Cannot assign an l-value to an r-value reference)
  ```

* R-value reference parameters

  ```cpp
  int x{100};				// x is an l-value
  
  void func(int &&num);	// B
  
  func(200);				// Calls B (200 is an r-value)
  func(x);				// Error (x is an l-value)
  						// - Cannot bind r-value reference of type 'int&&' to 
  						//   an l-value of type 'int'
  ```

* L-value reference parameters

  ```cpp
  int x{100};				// x is an l-value
  
  void func(int &num);	// A
  
  func(x);				// Calls A (x is an l-value)
  func(200);				// Error (200 is an r-value)
  						// - Cannot bind non-const l-value reference of type 'int&' to 
  						//   an r-value of type 'int'
  ```

* L-value and r-value reference parameters

  ```cpp
  int x{100};				// x is an l-value
  
  void func(int &num);	// A
  void func(int &&num);	// B
  
  func(x);				// Calls A (x is an l-value)
  func(200);				// Calls B (200 is an r-value)
  ```

* `Move` class WITHOUT move constructor

  ```cpp
  class Move
  {
  private:
      int *data;
  public:
      void set_data_value(int d)	{ *data = d; }
      int get_data_value()		{ return *data }
      Move(int d);				// Constructor
      Move(const Move &source);	// Copy constructor
      ~Move();					// Destructor
  };
  
  // Copy constructor (Deep copy)
  Move::Move(const Move &source)
  {
      data = new int;
      *data = *source.data;
  }
  ```

  > The move constructor 'steals' the data and nulls out the source pointer.

  Inefficient copying (Copy constructors will be called to copy the temps)

  ```cpp
  vector<Move> vec;
  
  vec.push_back(Move{10});
  vec.push_back(Move{20});
  ```

  > `Move{10}` and `Move{20}` create temporary objects which are unnamed and r-values. The compiler is going to use the copy constructor to make copies of these.
  >
  > Sample output:
  >
  > ```plain
  > Constructor for: 10
  > Constructor for: 10
  > Copy constructor (deep copy) for: 10
  > Destructor freeing data for: 10
  > Constructor for: 20
  > Constructor for: 20
  > Copy constructor (deep copy) for: 20
  > Constructor for: 10
  > Copy constructor (deep copy) for: 10
  > Destructor freeing data for: 10
  > Destructor freeing data for: 20
  > ```
  >
  > Copy constructor does several deep copies, which is very inefficient.

* `Move` class WITH move constructor

  ```cpp
  class Move
  {
  private:
      int *data;
  public:
      void set_data_value(int d)	{ *data = d; }
      int get_data_value()		{ return *data }
      Move(int d);				// Constructor
      Move(const Move &source);	// Copy constructor
      Move(Move &&source);		// Move constructor
      ~Move();					// Destructor
  };
  
  // Copy constructor (Deep copy)
  Move::Move(const Move &source)
  {
      data = new int;
      *data = *source.data;
  }
  
  // Move constructor
  Move::Move(Move &&source)
      : data{source.data}
  {
      source.data = nullptr;	// Null out source's pointer
  }
  ```

  Efficient copying (Move constructors will be called for the temp r-values)

  ```cpp
  vector<Move> vec;
  
  vec.push_back(Move{10});
  vec.push_back(Move{20});
  ```

  ```plain
  Constructor for: 10
  Move constructor (moving resource): 10
  Destructor freeing data for nullptr
  Constructor for: 20
  Move constructor (moving resource): 20
  Move constructor (moving resource): 10
  Destructor freeing data for nullptr
  Destructor freeing data for nullptr
  Destructor freeing data for: 10
  Destructor freeing data for: 20
  ```

  > No copy constructor is called at all. Instead, move constructor is being called.
  >
  > Also, note that the destructors are called for `nullptr`. That's destroying the object that we just moved and set its data pointer to `nullptr`.
