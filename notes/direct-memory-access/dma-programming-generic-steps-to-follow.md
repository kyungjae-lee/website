[Home](../../) | [Projects](../../projects) | [Notes](../) > <a href="./">Direct Memory Access (DMA)</a> > DMA Programming - Generic Steps to Follow

# DMA Programming - Generic Steps to Follow



## Generic Steps to Follow while using DMA in an Application

1. Identify the DMAx controller suitable for your application (Capability of each DMAx supported by your MCU may vary)
2. Initialize the DMA
3. Trigger the DMA (Manual or automatic trigger)
   * Manual trigger - Kick starting the DMA engine with the help of a processor core
   * Automatic trigger (Desirable) - Kick starting the DMA engine with help of a peripheral but not the processor core
4. Wait for Transmission Complete (TC) flag (i.e., polling) or get callback from DMA driver (i.e., interrupt)



## Important Initial Code

* DMA Handle

  The DMA handle is a data structure provided by the DMA HAL driver, used  by the application to manage the DMA controller of the MCU.

  ```c
  /* main.c */
  
  /* Private variables ---------------------------------------------------------*/
  DMA_HandleTypeDef hdma_memtomem_dma2_stream0;
  ```

  ```c
  /* stm32f4xx_hal_dma.h */
  
  /** 
    * @brief  DMA handle Structure definition
    */
  typedef struct __DMA_HandleTypeDef
  {
    DMA_Stream_TypeDef *Instance; /*!< Register base address */
    DMA_InitTypeDef Init;	/*!< DMA communication parameters */ 
    HAL_LockTypeDef Lock; /*!< DMA locking object */  
    __IO HAL_DMA_StateTypeDef State; /*!< DMA transfer state */
    void *Parent; /*!< Parent object state */ 
    void (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer complete callback */
    void (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA Half transfer complete callback */
    void (* XferM1CpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer complete Memory1 callback */
    void (* XferM1HalfCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer Half complete Memory1 callback */
    void (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer error callback */
    void (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer Abort callback */  
    __IO uint32_t ErrorCode; /*!< DMA Error code */
    uint32_t StreamBaseAddress; /*!< DMA Stream Base Address */
    uint32_t StreamIndex; /*!< DMA Stream Index */
  }DMA_HandleTypeDef;
  ```

* DMA Initialization

  `MX_DMA_Init()` function is auto-generated by the STM32CubeMX based on our configuration.

  ```c
  /* main.c */
  
  static void MX_DMA_Init(void);
  ```

  ```c
  /* main.c */
  
  /**
    * Enable DMA controller clock
    * Configure DMA for memory to memory transfers
    *   hdma_memtomem_dma2_stream0
    */
  static void MX_DMA_Init(void)
  {
  
    /* DMA controller clock enable */
    __HAL_RCC_DMA2_CLK_ENABLE();
  
    /* Configure DMA request hdma_memtomem_dma2_stream0 on DMA2_Stream0 */
    hdma_memtomem_dma2_stream0.Instance = DMA2_Stream0;
    hdma_memtomem_dma2_stream0.Init.Channel = DMA_CHANNEL_0;
    hdma_memtomem_dma2_stream0.Init.Direction = DMA_MEMORY_TO_MEMORY;
    hdma_memtomem_dma2_stream0.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_memtomem_dma2_stream0.Init.MemInc = DMA_MINC_DISABLE;
    hdma_memtomem_dma2_stream0.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_memtomem_dma2_stream0.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_memtomem_dma2_stream0.Init.Mode = DMA_NORMAL;
    hdma_memtomem_dma2_stream0.Init.Priority = DMA_PRIORITY_LOW;
    hdma_memtomem_dma2_stream0.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
    hdma_memtomem_dma2_stream0.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
    hdma_memtomem_dma2_stream0.Init.MemBurst = DMA_MBURST_SINGLE;
    hdma_memtomem_dma2_stream0.Init.PeriphBurst = DMA_PBURST_SINGLE;
    if (HAL_DMA_Init(&hdma_memtomem_dma2_stream0) != HAL_OK)
    {
      Error_Handler( );
    }
  }
  ```



## Using HAL Driver APIs



<img src="D:/repos/engineers-notebook/direct-memory-access/img/using-hal-driver-apis.png" alt="using-hal-driver-apis" width="1000">
